<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chat App – Real-Time Flow Diagrams</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: Arial, Helvetica, sans-serif;
      background: #f9fafb;
      color: #1f2937;
      margin: 40px;
      line-height: 1.6;
    }
    h1, h2, h3 {
      color: #111827;
    }
    h1 {
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 10px;
    }
    pre {
      background: #0f172a;
      color: #e5e7eb;
      padding: 20px;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 14px;
    }
    .note {
      background: #ecfeff;
      border-left: 4px solid #06b6d4;
      padding: 12px;
      margin: 20px 0;
    }
  </style>
</head>
<body>

  <h1>Real-Time Chat Application – Diagrams & Flow</h1>

  <p>
    This document visualizes how <strong>real-time message pushing</strong> works
    in a Node.js chat application using WebSockets (Socket.IO).
  </p>

  <h2>1. Traditional HTTP vs Real-Time (Why HTTP Fails)</h2>

  <pre>
Client (Browser)
     |
     |  HTTP Request (poll)
     v
Server
     |
     |  HTTP Response
     v
Client

❌ Server cannot push messages
❌ Client must keep asking
❌ High latency & wasted resources
  </pre>

  <div class="note">
    HTTP is request–response only. Chat requires server → client push.
  </div>

  <h2>2. WebSocket-Based Architecture (Core Diagram)</h2>

  <pre>
+-------------------+        WebSocket        +-------------------+
|                   | <--------------------> |                   |
|   UI (React /     |   Persistent, full-    |   Node.js Server  |
|   Angular / Vue)  |   duplex connection    |   (Socket.IO)     |
|                   |                        |                   |
+-------------------+                        +-------------------+
  </pre>

  <h3>Key Properties</h3>
  <pre>
✔ Connection stays open
✔ Server can send data anytime
✔ Client can send data anytime
  </pre>

  <h2>3. Message Send Flow (Step-by-Step)</h2>

  <pre>
User types message
        |
        v
+-------------------+
|       UI          |
| socket.emit()     |
+-------------------+
        |
        v
+-------------------+
|   Node.js Server  |
|  receives event  |
+-------------------+
        |
        |  (optional)
        |  Save to DB
        v
+-------------------+
| socket.broadcast |
|   .emit()        |
+-------------------+
        |
        v
+-------------------+
| Other Users' UI  |
| socket.on()      |
+-------------------+
        |
        v
UI updates instantly
  </pre>

  <h2>4. Async Push Explained (Event-Based)</h2>

  <pre>
Node.js Event Loop
------------------
while (connections open) {
  wait for event
  handle event async
  emit to clients
}

No blocking
No waiting for requests
Immediate push
  </pre>

  <h2>5. Rooms / Namespaces (Group Chat)</h2>

  <pre>
          +-------------------+
          |   Socket Server   |
          +-------------------+
             |        |
        Room A      Room B
         |  |        |  |
       U1  U2      U3  U4

Message in Room A
→ Only U1 and U2 receive it
  </pre>

  <div class="note">
    Rooms prevent broadcasting messages to everyone.
  </div>

  <h2>6. Scaling with Multiple Servers (Very Important)</h2>

  <pre>
        +-------------+
        |   Load      |
        |  Balancer   |
        +------+------+ 
               |
      -------------------------
      |                       |
+-------------+        +-------------+
| Node.js #1  |        | Node.js #2  |
| Socket.IO   |        | Socket.IO   |
+-------------+        +-------------+
      |                       |
      -------- Redis Adapter ------
                (Pub / Sub)

✔ Message sync across servers
✔ Horizontal scaling supported
  </pre>

  <h2>7. What Happens Without Redis (Problem)</h2>

  <pre>
User A connected to Node #1
User B connected to Node #2

Message sent from A
→ Node #1 broadcasts
→ B never receives ❌
  </pre>

  <h2>8. Authentication Flow (JWT with Sockets)</h2>

  <pre>
UI
 |
 |  WebSocket connect + JWT
 v
Server
 |
 |  Verify JWT
 |
 |-- valid → allow socket
 |
 |-- invalid → disconnect
  </pre>

  <h2>9. Reconnection Flow</h2>

  <pre>
Network drops
     |
     v
Socket disconnect
     |
     v
Socket.IO retries
     |
     v
Reconnected
     |
     v
Resume chat
  </pre>

  <h2>Summary</h2>

  <pre>
HTTP        → Not suitable for chat
WebSockets → Persistent, real-time
Socket.IO  → Events, rooms, reconnect
Redis      → Required for scaling
  </pre>

</body>
</html>
