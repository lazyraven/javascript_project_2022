<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JavaScript Q&A Plan</title>
<style>
    body {
        background-color: #111;
        color: #fff;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 20px;
    }

    .question-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 10px;
        margin-bottom: 20px;
    }

    .question-card {
        background: #1e1e1e;
        border: 1px solid #333;
        border-radius: 6px;
        padding: 10px;
        font-size: 14px;
        cursor: pointer;
        transition: 0.3s;
        text-align: center;
        line-height: 1.3;
    }

    .question-card:hover {
        background-color: #272727;
    }

    .definition-section {
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 25px;
        transition: all 0.4s ease;
    }

    .definition-section.highlight {
        border: 2px solid #b366ff;
        box-shadow: 0 0 15px #b366ff66;
        background: #2a1a3a;
    }

    .definition-section h3 {
        color: #b366ff;
        margin-bottom: 8px;
    }

    html {
        scroll-behavior: smooth;
    }

    /* === Back to Top Button Styling === */
    #backToTopBtn {
        display: none;
        position: fixed;
        bottom: 25px;
        right: 25px;
        background-color: #b366ff;
        color: #fff;
        border: none;
        border-radius: 50%;
        width: 45px;
        height: 45px;
        font-size: 20px;
        cursor: pointer;
        box-shadow: 0 0 10px #b366ff80;
        transition: all 0.3s ease;
        z-index: 1000;
    }

    #backToTopBtn:hover {
        background-color: #9933ff;
        box-shadow: 0 0 20px #b366ff;
        transform: scale(1.1);
    }
    /* === Floating Theme Toggle Button === */
    #themeToggle {
        position: fixed;
        top: 20px;
        right: 25px;
        z-index: 1100;
        cursor: pointer;
        background: #fff;
        color: #0d6efd;
        border: none;
        padding: 10px 16px;
        border-radius: 30px;
        font-weight: bold;
        font-size: 14px;
        box-shadow: 0 0 10px #b366ff60;
        transition: all 0.3s ease;
    }

    #themeToggle:hover {
        transform: scale(1.1);
        background: #0d6efd;
        color: #fff;
        box-shadow: 0 0 15px #b366ff90;
    }

    /* === Smooth Fade Animation for Theme Switch === */
    body {
        transition: background-color 0.5s ease, color 0.5s ease;
    }

    .definition-section,
    .question-card,
    #backToTopBtn {
        transition: background-color 0.5s ease, color 0.5s ease, box-shadow 0.5s ease;
    }

    /* === Light Mode === */
    body.light-mode {
        background-color: #f5f5f5;
        color: #111;
    }

    body.light-mode .question-card {
        background: #fff;
        border: 1px solid #ccc;
        color: #000;
    }

    body.light-mode .question-card:hover {
        background-color: #f0f0f0;
    }

    body.light-mode .definition-section {
        background: #fff;
        border: 1px solid #ddd;
        color: #000;
    }

    body.light-mode .definition-section h3 {
        color: #7a3fff;
    }

    body.light-mode #backToTopBtn {
        background-color: #7a3fff;
    }

    body.light-mode #themeToggle {
        background: #0d6efd;
        color: #fff;
    }

    /* === Responsive Adjustments === */
    @media (max-width: 600px) {
        #themeToggle {
            top: 15px;
            right: 15px;
            padding: 8px 14px;
            font-size: 13px;
        }
    }
    pre{
        font-size: 16px;
    }
</style>
</head>
<body> ‚úÖ Week 1 and ‚úÖ Week 5 ‚Äì JS And Other Topics
<button id="themeToggle">‚òÄÔ∏è Light</button>
<div>
    <h4><a target="_target"
            href="https://fullstack-interview-roadmap.netlify.app/">fullstack-interview-roadmap solution | ‚úÖ Week 1 ‚Äì
            Core JavaScript (1-20 Que)and | ‚úÖ Week 5 ‚Äì JS And Other Topics (Start from Que 21)</a>
    </h4>
</div>
  <div class="question-grid" id="questionGrid"></div>
  <div id="definitionContainer"></div>

  <!-- Back to Top Button -->
  <button id="backToTopBtn" title="Go to top">‚Üë</button>

  <script>
const jsInterviewQuestions = [
  {
    questionId: 1,
    question: "What is JavaScript?",
    definition: `
JavaScript (JS) is a high-level, interpreted programming language mainly used to make web pages interactive, dynamic, and functional.
It runs in the browser as well as on servers (using Node.js).

üëâ With JS, you can:
‚Ä¢ Manipulate the DOM (change HTML/CSS dynamically).
‚Ä¢ Handle user events (clicks, forms, etc.).
‚Ä¢ Communicate with servers (API calls).
‚Ä¢ Build full-stack applications.

In short: HTML gives structure, CSS gives style, and JavaScript gives behavior to web applications.
`
  },
  {
    questionId: 2,
    question: "var vs let vs const?",
    definition: `
In JavaScript:
‚Ä¢ var ‚Üí function-scoped and allows redeclaration.
‚Ä¢ let ‚Üí block-scoped, can be reassigned but not redeclared.
‚Ä¢ const ‚Üí block-scoped, cannot be reassigned.

Example:
var x = 10;  // function scope
let y = 20;  // block scope
const z = 30; // cannot reassign
`
  },
  {
    questionId: 3,
    question: "What is Scope?",
    definition: `
Scope defines the accessibility or visibility of variables, functions, and objects in different parts of the code.

Types of scope:
1. Global Scope ‚Äì variables accessible everywhere.
2. Function Scope ‚Äì variables declared inside a function are local to that function.
3. Block Scope ‚Äì variables declared using let and const inside {} are not accessible outside.
`
  },
  {
    questionId: 4,
    question: "What is hoisting?",
    definition: `
Hoisting means variable and function declarations are moved to the top of their scope before code execution.

üëâ Behavior:
var ‚Üí hoisted with default value undefined.
let ‚Üí hoisted but in the temporal dead zone (ReferenceError if accessed early).
const ‚Üí hoisted but must be initialized at declaration.

Example:
console.log(a); // undefined
var a = 10;

console.log(b); // ReferenceError
let b = 20;

console.log(c); // ReferenceError
const c = 30;
`
  },
  {
    questionId: 5,
    question: "What is a function?",
    definition: `
A function is a reusable block of code designed to perform a specific task.

Functions help to:
‚Ä¢ Organize code into smaller parts.
‚Ä¢ Reuse logic without rewriting.
‚Ä¢ Improve readability and maintainability.
`
  },
  {
    questionId: 6,
    question: "What is a closure? When is it useful? What is Lexical Scope?",
    definition: `
A closure is created when a function is defined inside another function and 
the inner function ‚Äúremembers‚Äù variables from the outer function even after the outer function has returned.

Use cases:
1. Data Privacy ‚Äì Hide variables.
2. Maintaining State ‚Äì Keep track of previous values.
3. Callbacks & Event Handlers - Useful when passing functions around; they can access the outer scope variables they were created with.
4. Functional Programming ‚Äì Currying, memoization, etc.

 ‚ú® In short: Closures are most useful when you need private variables, state persistence, or context preservation.

Example:
function counter() {
  let count = 0;
  return function() {
    count++;
    return count;
  };
}
const increment = counter();
console.log(increment()); // 1
console.log(increment()); // 2

Lexical Scope:
A function‚Äôs scope is determined by where it is defined in the code.
Inner functions can access outer function variables, not vice versa.
`
  },
  {
    questionId: 7,
    question: "What is IIFE (Immediately Invoked Function Expression)?",
    definition: `
An IIFE is a function that runs immediately after it is defined.

Example:
(function () {
  console.log("IIFE runs immediately!");
})();
`
  },
  {
    questionId: 8,
    question: "What are Prototypes?",
    definition: `
A prototype is an object from which other objects inherit properties and methods.

Prototype Chain:
If a property/method isn‚Äôt found on an object, JS looks up its prototype, then its prototype‚Äôs prototype, until it reaches null.

Example:
const obj = {};
console.log(obj.toString());
// Not in obj ‚Üí found in Object.prototype ‚Üí returns "[object Object]"
`
  },
  {
    questionId: 9,
    question: "How to deep clone an object?",
    definition: `
Deep cloning means creating a full copy of an object, including nested objects, 
so that changes in the copy don‚Äôt affect the original.

Modern Method:
const clone = structuredClone(obj);
 In Deep Learning : Go to this file console.log("file:///C:/workspace-nisha/01_github/02_Javascript/javascript_project_2022/basic-tut-2025/HTML/JavaScript");

`
  },
  {
    questionId: 10,
    question: "Difference between == and ===?",
    definition: `
== ‚Üí compares values only (performs type conversion).
=== ‚Üí compares both value and type (strict equality).

Example:
5 == "5"   // true
5 === "5"  // false
`
  },
  {
    questionId: 11,
    question: "Explain 'this' keyword in JS?",
    definition: `
The 'this' keyword refers to the object that is currently executing the function. 
Its value depends on how the function is called.

‚Ä¢ Inside an object method ‚Üí refers to the object.
‚Ä¢ In a regular function ‚Üí refers to global object (undefined in strict mode).
‚Ä¢ Inside a class or constructor ‚Üí refers to the instance.
‚Ä¢ Arrow functions ‚Üí do not have their own 'this'; they inherit from their lexical scope.
`
  },
  {
    questionId: 12,
    question: "What is call/apply/bind?",
    definition: `
‚Ä¢ call ‚Üí Immediately calls a function with a given 'this' and arguments individually.
‚Ä¢ apply ‚Üí Immediately calls a function with a given 'this' and arguments as an array.
‚Ä¢ bind ‚Üí Returns a new function with fixed 'this' and optional preset arguments.

Key difference:
call/apply = immediate execution.
bind = delayed (returns a new function).

‚ö° Key difference: call/apply = immediate execution, bind = future execution.
`
  },
  {
    questionId: 13,
    question: "Explain classes and inheritance?",
    definition: `
A class is a blueprint for creating objects ‚Äî it bundles properties and methods.

Inheritance allows one class (child) to use properties and methods of another class (parent) using 'extends'.

Key points:
‚Ä¢ constructor() runs when a new object is created.
‚Ä¢ super() calls parent constructor.
‚Ä¢ Child classes can override methods.
‚Ä¢ Classes are syntactic sugar over prototypes.
`
  },
  {
    questionId: 14,
    question: "What are Promises?",
    definition: `
A Promise represents the eventual completion (or failure) of an asynchronous operation.

States:
‚Ä¢ Pending ‚Üí initial.
‚Ä¢ Fulfilled ‚Üí resolved successfully.
‚Ä¢ Rejected ‚Üí failed.

Use .then() for success, .catch() for errors, .finally() for cleanup.
`
  },
  {
    questionId: 15,
    question: "Explain Async/Await?",
    definition: `
Async/Await (ES2017) are built on top of Promises.

‚Ä¢ async ‚Üí makes a function return a Promise.
‚Ä¢ await ‚Üí pauses execution until a Promise resolves/rejects.
‚Ä¢ Helps avoid callback hell.

Promise = chaining
async/await = clean synchronous-like code.
`
  },
  {
    questionId: 16,
    question: "Explain Promises and async/await together?",
    definition: `
Execution Order (Event Loop):

1. Sync code runs first (Start, End).
2. Microtasks (Promises, await) run next.
3. Macrotasks (setTimeout) run last.

Example Output:
Start
Inside async
End
Promise then
After await
setTimeout

Synchronous ‚Üí Microtasks ‚Üí Macrotasks.

console.log("Check Other practice => file:///C:/workspace-nisha/01_github/02_Javascript/javascript_project_2022/basic-tut-2025/HTML/promiseAsyncAwait.html");
Spoken Answer : 
                    *"In JavaScript, execution follows the event loop model. First, synchronous code runs top to bottom. After
                     that, microtasks like Promise.then() and await callbacks run before macrotasks like setTimeout.

                    Promises are objects representing the result of an async operation, and we handle them with .then() or
                     .catch(). Async/await is built on top of Promises and makes async code look synchronous, improving readability.

                    For example, if I combine setTimeout, Promises, and async/await, the order is always: sync code first, 
                    then microtasks from Promises or await, and finally macrotasks like setTimeout. This is why understanding the 
                    event loop is crucial when debugging async behavior."*
                     Chcek => "js_async_cheatsheet.pdf"
`
  },
  {
    questionId: 17,
    question: "What are sequential promises?",
    definition: `
Sequential Promises:
Execute one after another ‚Äî each waits for the previous to resolve.
‚Ä¢ Useful when tasks are dependent on each other.   

Parallel Promises:
Run simultaneously ‚Äî independent tasks that don‚Äôt wait for each other.
‚Ä¢ Useful when tasks are independent.
`
  },
  {
    questionId: 18,
    question: "Explain the event loop?",
    definition: `
The event loop continuously checks the call stack and callback/microtask queues,
allowing asynchronous operations without blocking the main thread.

Cycle:
Call Stack ‚Üí Microtask Queue (Promises) ‚Üí Macrotask Queue (setTimeout, I/O)
`
  },
  {
    questionId: 19,
    question: "Explain Debounce & Throttle?",
    definition: `
Debounce:
Delays a function‚Äôs execution until after a specified time of no calls ‚Äî great for search boxes.
mainly used to improve performance

Throttle:
Executes a function at fixed intervals ‚Äî great for scroll or resize events.

Difference:
Debounce waits for silence.
Throttle runs on schedule.

Example:
Debounce: Typing ‚Üí run after user stops.
Throttle: Scrolling ‚Üí run every 200ms.
`
  },
  {
    questionId: 20,
    question: "Difference between process.nextTick and setImmediate (Node-specific)?",
    definition: `
process.nextTick ‚Üí Runs immediately after the current function, before event loop continues.
setImmediate ‚Üí Runs on the next event loop cycle (after I/O).

Use Cases:
‚Ä¢ nextTick ‚Äì urgent microtasks.
‚Ä¢ setImmediate ‚Äì defer heavy tasks post I/O.

Not Required for answer:
To use Node-specific features (process) inside the browser, which doesn‚Äôt have them.
`
  },
  {
    questionId: 21,
    question: "How many things do you know about JS?",
    definition: `
JavaScript is a high-level, versatile language for building dynamic web applications.\nI have a strong grasp of its fundamentals, including ES6 features, async programming, and frameworks like React, Angular, Vue, and Node.js for full-stack development.
`
  },
  { 
        questionId: 22, 
        question: "What is ES6?", 
        definition : `
ES6 is the 2015 update to JavaScript that introduced modern features\n like let, const, arrow functions, classes, modules, and promises ‚Äî making code cleaner, easier, and more efficient.
` 
  },
  {
    questionId: 23,
    question: "What is the difference between Real DOM and Virtual DOM?",
    definition: `
Real DOM:
    ‚Ä¢ Represents the actual structure of the webpage in the browser.
    ‚Ä¢ When a change occurs, the entire page or large sections re-render ‚Äî making it slower.

Virtual DOM:
    \n‚Ä¢ A lightweight copy of the Real DOM used by frameworks like React.
    \n‚Ä¢ It updates only the modified parts by comparing (diffing) the Virtual DOM with the Real DOM ‚Äî making it faster and more efficient.

In Short:
    ‚Ä¢ Real DOM: Updates the whole UI directly ‚Äî slower.
    ‚Ä¢ Virtual DOM: Updates only what‚Äôs changed ‚Äî faster and smoother.
`
  },
{
    questionId: 24,
    question: "What are Web Selectors?",
    definition: `
A web selector (also called as CSS selector) is a pattern used in web development to sleect and target specific HTML elements on a webpage,
so you can apply style (using css) or manipulate them (using javascript). 
In short- selectors tell the browser ‚Äúwhich element(s) this rule applies to.

1. The Universal Selector (*) selects all elements on a webpage.  
   Example:
   * {
     margin: 0;
     padding: 0;
   }

2. The Element Selector (div, p, h1, etc.) targets all elements of a specific type.  
   Example:
   p {
     color: blue;
   }

3. The Class Selector (.classname) targets elements with a specific class attribute.  
   Example:
   .highlight {
     background-color: yellow;
   }

4. The ID Selector (#idname) targets a unique element with a specific ID.  
   Example:
   #header {
     font-size: 20px;
   }

5. The Attribute Selector ([attr=value]) selects elements with a particular attribute or value.  
   Example:
   input[type="text"] {
     border: 1px solid gray;
   }

6. The Descendant Selector (parent child) targets elements nested inside another element.  
   Example:
   div p {
     color: green;
   }

7. The Pseudo-class Selector (:hover, :nth-child(), etc.) targets elements based on their state or position.  
   Example:
   a:hover {
     color: red;
   }

8. The Pseudo-element Selector (::before, ::after) styles specific parts of an element.  
   Example:
   p::first-letter {
     font-size: 24px;
   }

9. In JavaScript, selectors are also used to access elements.  
   Example:
   document.querySelector(".btn");      // Selects the first element with class "btn"
   document.querySelectorAll("p");      // Selects all <p> elements
   document.getElementById("header");   // Selects the element with ID "header"
`
  },
  { 
        questionId: 25, 
        question: "Explain Web Storage, Cookies, Session Storage, Local Storage? what does mean Data Persistence ?",
        definition : `Data Persistence means keeping data available even after the page reloads or the app is closed.

1. LocalStorage : backs up (saves) some data into localStorage, so the data remains even after:
    \n‚Ä¢ Stores data with no expiration,\n‚Ä¢ Data stays even after closing the browser,\n‚Ä¢ Example use: saving theme preference, login state (non-sensitive), cart items.

2. SessionStorage
    ‚Ä¢ Stores data only for the current browser tab/session
    ‚Ä¢ Data disappears when the tab is closed
    ‚Ä¢ Example use: form progress, one-session tokens

Why it‚Äôs useful
    ‚Ä¢ Faster access to data (no server call)
    ‚Ä¢ Simple key‚Äìvalue storage  
    ‚Ä¢ Helpful for personalizing UI or maintaining state

                                    localStorage.setItem("username", "Nisha");
                                    const name = localStorage.getItem("username"); // "Nisha"

3. Cookies
   ‚Ä¢ Expire based on an expiration date (you set it)
   ‚Ä¢ Sent to Server > Sent automatically with each HTTP request
   ‚Ä¢ Accessible by JavaScript and the server
   ‚Ä¢ Can be HttpOnly, Secure, SameSite ‚Üí This makes them safer for authentication when used properly.


What to Use When

    Use localStorage when:
    Saving theme (dark/light)
    Saving user settings
    Storing non-sensitive UI data
    Saving cart items for a shopping website

    Use sessionStorage when:
    Temporary form data
    Data that should clear after closing a tab
    One-time session preferences

    Use Cookies when:
    Authentication (session ID, secure tokens)
    Server-side validation
    Managing logged-in states securely


    | Feature         | localStorage       | sessionStorage    | Cookies                     |
|-----------------|--------------------|--------------------|-----------------------------|
| Capacity        | 5‚Äì10 MB            | 5‚Äì10 MB            | ~4 KB                       |
| Lifetime        | Until removed      | Until tab closes   | Custom expiry               |
| Sent to server? | No                 | No                 | Yes                         |
| Secure options  | None               | None               | HttpOnly, Secure, SameSite  |
| Best use        | UI data, prefs     | Temporary data     | Auth, server communication  |

          ` 
  },
  { 
        questionId: 26, 
        question: "Client-side vs Server-side rendering?", 
        definition : `
Client-Side Rendering (CSR)

  ‚Ä¢ The browser downloads a minimal HTML file and JavaScript.
  ‚Ä¢ JavaScript builds the UI in the browser.
  ‚Ä¢ Pros: Rich interactions, fast after initial load.
  ‚Ä¢ Cons: Slow first load, weaker SEO unless handled properly.

Server-Side Rendering (SSR)

  ‚Ä¢ The server generates the full HTML for each request.
  ‚Ä¢ Browser gets a ready page.
  ‚Ä¢ Pros: Faster first load, better SEO.
  ‚Ä¢ Cons: More server load, slower page updates after interactions.
  
one-sentence interview version:
 
 CSR renders the UI in the browser using JavaScript, while SSR renders the HTML on the server before sending it to the browser‚ÄîCSR is better for rich interactions,
 and SSR is better for initial load speed and SEO.
  ` 
  },
  { 
        questionId: 27, 
        question: "JavaScript multithreaded or single-threaded?", 
        definition : `
JavaScript is single-threaded

  ‚Ä¢ It runs one task at a time using the main thread.
  ‚Ä¢ Concurrency is handled through the event loop, callbacks, promises, and async/await‚Äînot by true multithreading.
  ‚Ä¢ Web Workers can add parallelism, but they run on separate threads outside the main thread.

` 
  },
  { 
        questionId: 28, 
        question: "Difference between one-way and two-way binding?", 
        definition : `
One-Way Binding

  ‚Ä¢ Data flows in a single direction (model ‚Üí UI).
  ‚Ä¢ UI updates when data changes, but UI doesn‚Äôt directly change the model.

  Two-Way Binding

  ‚Ä¢ Data flows both ways (model ‚Üî UI).
  ‚Ä¢ Changing the UI updates the model, and changing the model updates the UI automatically.

` 
  },
  { 
        questionId: 29, 
        question: "How to validate String, Object, and Array? & Definition", 
        definition : `
Validate String

  ‚Ä¢ typeof value === "string" and value.trim().length > 0.

Validate Object

  ‚Ä¢ typeof value === "object" and value !== null and !Array.isArray(value).

Validate Array

  ‚Ä¢ Array.isArray(value) and value.length > 0 (if non-empty required).

String: A sequence of characters used to represent text.
Object: A collection of key‚Äìvalue pairs used to store structured data.
Array: An ordered list of values stored by index.
` 
  },
  { 
        questionId: 30, 
        question: "Explain Array methods?", 
        definition : ` Array methods let you add, remove, search, and transform items‚Äîfor example: push/pop (add/remove), map (transform), filter (select), reduce (summarize), and find (locate).
Common Array Methods
  ‚Ä¢ push() ‚Äì Adds an item to the end.

  ‚Ä¢ pop() ‚Äì Removes the last item.

  ‚Ä¢ shift() ‚Äì Removes the first item.

  ‚Ä¢ unshift() ‚Äì Adds an item to the start.

  ‚Ä¢ map() ‚Äì Creates a new array by transforming each element.

  ‚Ä¢ filter() ‚Äì Returns items that match a condition.

  ‚Ä¢ reduce() ‚Äì Reduces the array to a single value.

  ‚Ä¢ forEach() ‚Äì Runs a function on each element (no return).

  ‚Ä¢ find() ‚Äì Returns the first matching item.
` 
  },
  { 
        questionId: 31, 
        question: "Explain map, filter, and reduce?", 
        definition : `
map(): Creates a new array by applying a function to each element.

filter(): Returns a new array with elements that match a condition.

reduce(): Combines all elements into a single value (like sum or total).
` 
  },
  { 
        questionId: 32, 
        question: "What are Higher-Order Functions?", 
        definition : `Functions that take other functions as arguments or return a function. They make code more reusable and flexible.` 
  },
  { 
        questionId: 33, 
        question: "Difference between splice, slice, and reduce?", 
        definition : `
slice(): Returns a new array by copying a portion of the array without modifying the original.

splice(): Adds or removes elements from the array and modifies the original array.

reduce(): Processes all elements and returns a single value, not an array.
` 
  },
  { 
        questionId: 34, 
        question: "Difference between includes() and find()?", 
        definition : `
includes(): Checks if a value exists in the array and returns true/false.

find(): Returns the first matching element based on a condition.` 
  },
  { 
        questionId: 35, 
        question: "What is the spread operator?", 
        definition : `
Spread Operator (...): Expands arrays or objects into individual elements, making it easy to copy, merge, or pass values.
` 
  },
  { 
        questionId: 36, 
        question: "Difference between deep and shallow copy?", 
        definition : `
Shallow Copy: Copies only the top-level values; nested objects still reference the same memory.

Deep Copy: Copies all levels of data; nested objects get completely new independent copies.
` 
  },
  { 
        questionId: 37, 
        question: "What is a key in JS?", 
        definition : `
Key in JavaScript: A key is the name of a property in an object used to access its corresponding value.
` 
  },
  { 
        questionId: 38, 
        question: "How many loops are used in JS?", 
        definition : `
JavaScript has several loops: for, while, do‚Ä¶while, for‚Ä¶of, for‚Ä¶in, and array loops like forEach().` 
  },
  { 
        questionId: 39, 
        question: "Difference between for loop and forEach loop?", 
        definition : `
for loop: Gives full control over index, conditions, and breaking out of the loop.
          A traditional loop that lets you control the counter, skip steps, and stop the loop whenever you want.

forEach(): Executes a function on each array item but can‚Äôt break early and is used mainly for cleaner array iteration.
` 
  },
  { 
        questionId: 40, 
        question: "Difference between vanilla JS and JS, frameworks?", 
        definition : `
Vanilla JS vs JavaScript

  ‚Ä¢ JavaScript is the programming language itself.

  ‚Ä¢ Vanilla JavaScript simply means using plain, pure JavaScript without any libraries or frameworks.

One-line summary:
  Vanilla JS is just JavaScript in its raw form, without added tools.


JavaScript Frameworks (React, Angular, Vue, etc.)

  ‚Ä¢ Provide pre-built structure, patterns, and tools for building complex UIs faster.

  ‚Ä¢ Handle things like state management, routing, and efficient DOM updates.

  ‚Ä¢ Improve productivity and maintainability for larger applications.
` 
  },
  { 
        questionId: 41, 
        question: "What is an anonymous function?", 
        definition : `
Anonymous Function

  ‚Ä¢ A function without a name.

  ‚Ä¢ Used when the function is needed temporarily, such as in callbacks, event handlers, or array methods.

Example:
() => { console.log("Hello"); }

One-line summary:
An anonymous function is a nameless function used mainly for short, inline operations.
` 
  },
  { 
        questionId: 42, 
        question: "Explain isNaN() function?", 
        definition : `
isNaN() Function

  ‚Ä¢ isNaN() checks whether a value is Not-a-Number.

  ‚Ä¢ It returns true if the value cannot be converted into a valid number, otherwise false.

Example:
isNaN("abc") // true
isNaN("20") // false

One-line summary:
isNaN() tells you if a value is not a valid number.
` 
  },
  { 
        questionId: 43, 
        question: "How to handle exceptions in JS?", 
        definition : `
Handling Exceptions in JavaScript

 ‚Ä¢ Use try‚Äìcatch to catch and handle errors.

 ‚Ä¢ try contains the code that may fail, catch handles the error, and finally runs always (optional).
                                                        try {
                                                          riskyFunction();
                                                        } catch (error) {
                                                          console.error(error);
                                                        } finally {
                                                          cleanup();
                                                        }
One-line summary:
Use try‚Äìcatch to safely catch and manage errors in JavaScript.
` 
  },
  
  { 
        questionId: 44, 
        question: "What is event propagation?", 
        definition : `
Event Propagation
One-line summary: Event propagation defines how events travel through the DOM in capturing and bubbling phases. OR

 ‚Ä¢ Event propagation is the flow of events through the DOM in two phases:

    1. Capturing phase ‚Äì event moves from parent to child.

    2. Bubbling phase ‚Äì event moves from child back up to parent.
` 
  },
  { 
        questionId: 45, 
        question: "What is event bubbling?", 
        definition : `
Event Bubbling

One-line summary: Event bubbling is when an event triggers on the child first and then propagates up to the parent elements.
 
 ‚Ä¢ Event bubbling means an event starts from the deepest (child) element and moves upward through its parent elements.

 ‚Ä¢ It helps handle events at a higher level without attaching many listeners.
` 
  },
  { 
        questionId: 46, 
        question: "How to fix a 404 error?", 
        definition : `
Fixing a 404 Error

 ‚Ä¢ A 404 happens when a page or resource is not found.

 ‚Ä¢ Check and correct the URL, ensure the file or route exists, and verify the server or API path is correct.

One-line summary:
Fix a 404 by correcting the URL or making sure the requested resource actually exists on the server.
` 
  },
  { 
        questionId: 47, 
        question: "What is a CORS issue and what is a proxy?", 
        definition : `
CORS Issue

 ‚Ä¢ CORS (Cross-Origin Resource Sharing) happens when a browser blocks requests to a different domain or port for security reasons.

 ‚Ä¢ It occurs when the server doesn‚Äôt allow your origin.

Proxy

 ‚Ä¢ A proxy is a middle layer that forwards your request to another server.

 ‚Ä¢ It helps bypass CORS by making the request from the server side instead of the browser.

One-line summary:
A CORS issue is a blocked cross-domain request, and a proxy is a server that forwards requests to avoid such restrictions.
` 
  },
  { 
        questionId: 48, 
        question: "Explain HTTP request methods?", 
        definition : `
 ‚Ä¢ HTTP Request Methods

 ‚Ä¢ GET ‚Äì Fetch data from the server.

 ‚Ä¢ POST ‚Äì Send new data to the server.

 ‚Ä¢ PUT ‚Äì Update or replace existing data.

 ‚Ä¢ PATCH ‚Äì Partially update data.

 ‚Ä¢ DELETE ‚Äì Remove data from the server.

One-line summary:
HTTP methods define the type of action you want to perform on a server‚Äôs resource.
` 
  },
  { 
        questionId: 49, 
        question: "Explain HTTP status codes (400, 401, 404, 500, 502)?", 
        definition : `
HTTP Status Codes

 ‚Ä¢ 400 ‚Äì Bad Request: The server can‚Äôt process the request due to invalid input.

 ‚Ä¢ 401 ‚Äì Unauthorized: Authentication is required or failed.

 ‚Ä¢ 404 ‚Äì Not Found: The requested resource doesn‚Äôt exist.

 ‚Ä¢ 500 ‚Äì Internal Server Error: Server encountered an unexpected error.

 ‚Ä¢ 502 ‚Äì Bad Gateway: The server received an invalid response from another server.

One-line summary:
These codes indicate different client or server errors that help identify what went wrong in a request.
` 
  },
  { 
        questionId: 50, 
        question: "What is a recursive function?", 
        definition : `
Recursive Function

 ‚Ä¢ A function that calls itself to solve a problem.

 ‚Ä¢ Used for tasks that can be broken into smaller, similar subproblems (e.g., factorial, tree traversal).

One-line summary:
A recursive function solves a problem by repeatedly calling itself with smaller inputs.
` 
  },
  { 
        questionId: 51, 
        question: "Explain JWT?", 
        definition : `
JWT (JSON Web Token)

 ‚Ä¢ JWT is a secure token format used for authentication.

 ‚Ä¢ It contains encoded user data and is signed so it can‚Äôt be tampered with.

 ‚Ä¢ The server verifies the token instead of checking the database each time.

One-line summary:
JWT is a signed token used to verify user identity without repeated database lookups.
` 
  },
  { 
        questionId: 52, 
        question: "Currying, memoization?", 
        definition : `
Currying

 ‚Ä¢ Breaking a function with multiple arguments into a series of functions that take one argument at a time.

 ‚Ä¢ Helps reuse functions and improves code flexibility.

Memoization

 ‚Ä¢ Caching a function‚Äôs previous results to avoid recalculating.

 ‚Ä¢ Improves performance for expensive operations.

One-line summary:
Currying transforms functions into smaller ones; memoization speeds them up by caching results.
` 
  },
];

    const questionGrid = document.getElementById("questionGrid");
    const definitionContainer = document.getElementById("definitionContainer");

    jsInterviewQuestions.forEach(item => {
      // create top question box
      const card = document.createElement("div");
      card.className = "question-card";
      card.innerHTML = `<strong style="color:#b366ff;">Q${item.questionId}:</strong> ${item.question}`;
      card.addEventListener("click", () => scrollToDefinition(item.questionId));
      questionGrid.appendChild(card);

      // create definition section
      const def = document.createElement("div");
      def.className = "definition-section";
      def.id = `question-${item.questionId}`;
      def.innerHTML = `
        <h3>Question ${item.questionId}: ${item.question}</h3>
        <pre>${item.definition}</pre>
      `;
      definitionContainer.appendChild(def);
    });

    function scrollToDefinition(id) {
      const target = document.getElementById(`question-${id}`);
      if (target) {
        target.scrollIntoView({ behavior: "smooth", block: "start" });
        target.classList.add("highlight");
        setTimeout(() => target.classList.remove("highlight"), 1500);
      }
    }

    
    // === Back to Top Button Logic ===
    const backToTopBtn = document.getElementById("backToTopBtn");

    window.addEventListener("scroll", () => {
      if (document.body.scrollTop > 300 || document.documentElement.scrollTop > 300) {
        backToTopBtn.style.display = "block";
      } else {
        backToTopBtn.style.display = "none";
      }
    });

    backToTopBtn.addEventListener("click", () => {
      window.scrollTo({ top: 0, behavior: "smooth" });
    });


   /// === Theme Toggle Logic with Icons and Fade ===
    const themeToggle = document.getElementById("themeToggle");
    const body = document.body;

    // Load saved theme preference
    if (localStorage.getItem("theme") === "light") {
    enableLightMode(false);
    } else {
    enableDarkMode(false);
    }

    themeToggle.addEventListener("click", () => {
    body.classList.add("fade-transition");
    if (body.classList.contains("light-mode")) {
        enableDarkMode();
    } else {
        enableLightMode();
    }
    setTimeout(() => body.classList.remove("fade-transition"), 400);
    });

    function enableLightMode(save = true) {
    body.classList.add("light-mode");
    themeToggle.innerHTML = "üåô Dark";
    if (save) localStorage.setItem("theme", "light");
    }

    function enableDarkMode(save = true) {
    body.classList.remove("light-mode");
    themeToggle.innerHTML = "‚òÄÔ∏è Light";
    if (save) localStorage.setItem("theme", "dark");
    }
  </script>
</body>
</html>
