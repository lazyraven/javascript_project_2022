<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Theory Javascript</title>
</head>
<style>
    body {
         /* background: #333;
        color: whitesmoke; */
        font-family: Verdana, Geneva, Tahoma, sans-serif
            /* font-family: 'Brush Script MT', cursive; */
    }

    .blue {
        color: blueviolet;
        font-weight: bold;
        display: inline;
    }

    p,
    pre {
        font-size: 16px;
    }

    #customlist {
        /* delete default counter */
        list-style-type: none;
        /* create custom counter and set it to 0 */
        counter-reset: elementcounter;
    }

    #customlist>li:before {
        /* print out "Element " followed by the current counter value */
        content: "Question " counter(elementcounter) ": ";
        /* increment counter */
        counter-increment: elementcounter;
        font-weight: bold;
        color: blueviolet;
    }
</style>

<body>
    <ol id="customlist">
        <li>
            <h4 class="blue">What is Javasecript ?</h4>
            <pre>
            JavaScript (JS) is a high-level, interpreted programming language mainly used to make web pages interactive, dynamic, and functional.
            It runs in the browser as well as on servers (using Node.js).

                üëâ With JS, you can:
                ‚Ä¢ Manipulate the DOM (change HTML/CSS dynamically).
                ‚Ä¢ Handle user events (clicks, forms, etc.).
                ‚Ä¢ Communicate with servers (API calls).
                ‚Ä¢ Build full-stack applications.

            In short: HTML gives structure, CSS gives style, and JavaScript gives behavior to web applications.
            </pre>
        </li>
        <li>
            <h4 class="blue">var vs let vs const </h4>
            <div>
                <pre>Definition : In JavaScript, var is function-scoped and allows redeclaration,
                            while let is block-scoped and can only be reassigned, not redeclared.
                            const is also block-scoped but values can‚Äôt be reassigned.</pre>
            </div>
        </li>
        <li>
            <h4 class="blue">What is Scope ? </h4>
            <div>
                <pre>Definition : In JavaScript, scope defines the accessibility or visibility of variables, functions, and objects in different parts of the code.</pre>
                <pre>There are mainly three types of scope:

                    1. Global Scope ‚Äì variables accessible everywhere in the code.
                    2. Function Scope ‚Äì variables declared inside a function are accessible only within that function.
            </div>
        </li>
        <li>
            <h4 class="blue">What is hoisting? </h4>
            <div>
                <p>Definition : Hoisting in JavaScript means variable and function declarations are moved to the top of
                    their
                    scope before code execution.</p>
                <pre>üëâ Explanation:
                   var ‚Üí hoisted with default value undefined.
                   let ‚Üí hoisted but in temporal dead zone, gives ReferenceError.
                   const ‚Üí same as let, but must be initialized at declaration.
                </pre>
                <pre>
            example covering var, let, and const hoisting in one go:
        <code>
            // var example
            console.log(a); // undefined
            var a = 10;

            // let example
            console.log(b); // ReferenceError
            let b = 20;

            // const example
            console.log(c); // ReferenceError
            const c = 30;
        </code>
        </pre>
            </div>
        </li>
        <li>
            <h4 class="blue">What is functions ? </h4>
            <div>
                <pre>Definition : A function in JavaScript is a reusable block of code designed to perform a specific task when called.
                They help in:
                    ‚Ä¢ Organizing code into smaller parts.
                    ‚Ä¢ Reusing logic without rewriting.
                    ‚Ä¢ Improving readability and maintainability.</pre>
            </div>
        </li>
        <li>
            <h4 class="blue">What is closure? </h4>
            <div>
                <pre>Definition : In JavaScript, a closure is created when a function is defined inside another function and 
                    the inner function "closes over" (remembers) the variables of the outer function.
                    It allows the inner function to access and manipulate those outer variables even after the outer function has returned.</pre>
                OR
                <pre>
            Closures : A closure is formed when a function ‚Äúremembers‚Äù its lexical scope even after the outer function has finished.
                       lexical scope means => inner function is lexical scope.
                    </pre>
                <h4 class="blue">Question 6.1: When is it(closure) useful? </h4>
                <pre>
                      1. Data Privacy / Encapsulation => You can hide variables from the outside world and expose only what‚Äôs necessary.
                      2. Maintaining State => Closures let functions "remember" past values even after their outer function has executed.
                      3. Callbacks & Event Handlers => Useful when passing functions around; they can access the outer scope variables they were created with.
                      4. Functional Programming => Helpful in currying, memoization, and creating higher-order functions.

                      ‚ú® In short: Closures are most useful when you need private variables, state persistence, or context preservation.
                      
                      Example :
                      function counter() {
                            let count = 0;
                            return function () {
                                count++;
                                return count;
                            };
                        }
                        const increment = counter();
                        console.log(increment()); // 1
                        console.log(increment()); // 2

          </pre>
                <h4 class="blue">Question 6.2: What is Lexical Scope? </h4>
                <pre>Definition : Lexical scope means a function‚Äôs scope is determined by where it is written in the code (not where it is called).
                Inner functions can access variables from their outer functions, but the reverse isn‚Äôt true.
          </pre>
            </div>
        </li>

        <li>
            <h4 class="blue">What is IIFE (Immediately Invoked Function Expression) ? </h4>
            <div>
                <pre>Definition : An IIFE (Immediately Invoked Function Expression) is a JavaScript function that executes immediately after it is defined.
            
            <code>(function () {
            console.log("IIFE runs immediately!");
            })();
            </code>
        </pre>
            </div>
        </li>

        <li>
            <h4 class="blue">What is Prototypes ? </h4>
            <div>
                <pre>Definition : A prototype in JavaScript is an object from which other objects inherit properties and methods.
                                
                    Prototype chain in one line:
                If a property or method isn‚Äôt found on an object, JavaScript looks up its prototype, then the prototype‚Äôs prototype, and
                so on, until it reaches null.
                
                const obj = {};
                console.log(obj.toString());
                // Not found in obj ‚Üí found in Object.prototype ‚Üí returns "[object Object]"
                </pre>
            </div>
        </li>
        <li>
            <h4 class="blue">Deep clone object ? </h4>
            <div>
                <pre>Definition : Deep clone means making a full copy of an object, including all nested objects, so changes in the copy don‚Äôt affect the original.
                    
                    const clone = structuredClone(obj);
                    Best modern way (handles nested objects, arrays, Dates, Maps, Sets).

                    In Deep Learning : Go to this file C:\workspace-nisha\01_github\02_Javascript\javascript_project_2022\basic-tut-2025\JavaScript
                </pre>
            </div>
        </li>

        <li>
            <h4 class="blue">Difference between == and === </h4>
            <div>
                <pre>Definition :  == checks only for value equality with type conversion, while === checks for both value and type without conversion.
                    == ‚Üí compares only value.
                    === ‚Üí compares value + type.

                    5 == "5"   // true
                    5 === "5"  // false
                </pre>
            </div>
        </li>

        
        <li>
            <h4 class="blue">Explain this keyword in JS ? </h4>
            <div>
                <pre>Definition : In JavaScript, the this keyword is a special reference that points to the object that is currently executing the function. Its value depends on how the function is called, not where it is defined.
                        ‚Ä¢  this depends on how a function is called.
                        ‚Ä¢ Arrow functions do not bind their own this.

                 1. Inside an Object Method : 
                 2. In a Regular Function (Global Scope) :   
                 3. Inside a Constructor Function :  
                 4. In a Class :   
                 5. Arrow Functions :  
                </pre>
            </div>
        </li>

        <li>
            <h4 class="blue">What is call/apply/bind ?</h4>
            <div>
                <pre>Definition : 
                    ‚Ä¢ call ‚Üí Immediately invokes a function with a given this and arguments passed individually.

                    ‚Ä¢ apply ‚Üí Immediately invokes a function with a given this and arguments passed as an array.

                    ‚Ä¢ bind ‚Üí Returns a new function with a fixed this (and optional preset arguments), without calling it immediately.
               
               ‚ö° Key difference: call/apply = immediate execution, bind = future execution.
                </pre>
            </div>
        </li>

         <li>
            <h4 class="blue"> Classes & inheritance ?</h4>
            <div>
                <pre>Definition : 1. What is a Class in JavaScript?
                    ‚Ä¢ A class is a blueprint for creating objects.
                    ‚Ä¢ It bundles properties (data) and methods(functions) together.
                    ‚Ä¢ Behind the scenes, classes use prototypes.

                    üîπ 2. Inheritance
                    ‚Ä¢ Inheritance means one class can extend another.
                    ‚Ä¢ The child class inherits the parent's properties/methods and can also add its own.
                    ‚Ä¢ Achieved with the extends keyword.
                     OR 
                     Inheritance allows a class (child) to use properties and methods of another class (parent).

                    üîπ 3. Key Points
                    ‚Ä¢ constructor() runs when you create a new object.
                    ‚Ä¢ super() is used in the child class to call the parent‚Äôs constructor.
                    ‚Ä¢ Child classes can override methods.
                    ‚Ä¢ Classes are syntactic sugar over prototypes.
                </pre>
            </div>
        </li>

         <li>
            <h4 class="blue">What is Promises ?</h4>
            <div>
             <pre>Definition : 1. Promise: A Promise is an object that represents the eventual completion (or failure) of an asynchronous operation.

                    ‚Ä¢ It has 3 states:
                            ‚Ä¢ Pending ‚Üí initial state.
                            ‚Ä¢ Fulfilled ‚Üí operation completed successfully (resolved).
                            ‚Ä¢ Rejected ‚Üí operation failed (error).

                    ‚Ä¢ We use .then() for handling success and .catch() for handling errors, with .finally() for cleanup.
                </pre>
            </div>
        </li>

         <li>
            <h4 class="blue"> Explain Async/Await ?</h4>
            <div>
                <pre>Definition : 2. Async/Await: Introduced in ES2017, built on top of Promises.

                    ‚Ä¢ async makes a function return a Promise.
                    ‚Ä¢ await pauses execution until a Promise is resolved/rejected, making async code look synchronous.
                    ‚Ä¢ Helps avoid callback hell and makes code cleaner.

                    üëâ Promise = chaining
                    üëâ async/await = clean, synchronous-like</pre>
            </div>
        </li>

         <li>
            <h4 class="blue">Explain Promises, async/await ? </h4>
            <div>
                <pre> 
                    Expected Answer
                Step-by-step reasoning:

                1. Synchronous execution first:
                    ‚Ä¢ Logs "Start".
                    ‚Ä¢ Schedules setTimeout callback in the macrotask queue.
                    ‚Ä¢ Creates a resolved Promise ‚Üí schedules "Promise then" in the microtask queue.
                    ‚Ä¢ Calls test():
                    ‚Ä¢ Logs "Inside async".
                    ‚Ä¢ Hits await Promise.resolve(), which pauses execution and schedules "After await" in the microtask queue.
                    ‚Ä¢ Logs "End".

                2. Microtasks run before macrotasks:
                    ‚Ä¢ "Promise then" logs.
                    ‚Ä¢ "After await" logs.
                    ‚Ä¢ The await pauses execution until the Promise resolves.

                3. Finally, macrotasks run:
                    ‚Ä¢ "setTimeout" logs.

                    üëâ Output:
                                Start   
                                Inside async
                                End
                                Promise then
                                After await
                                setTimeout


                        ‚Ä¢ Synchronous code runs first.
                        ‚Ä¢ Microtasks (Promises, async/await) run next.
                        ‚Ä¢ Macrotasks (setTimeout, setInterval, I/O) run last.

                        console.log("Check Other practice => file:///C:/workspace-nisha/01_github/02_Javascript/javascript_project_2022/basic-tut-2025/HTML/promiseAsyncAwait.html");
                    
                    
                    Spoken Answer : 
                    *"In JavaScript, execution follows the event loop model. First, synchronous code runs top to bottom. After
                     that, microtasks like Promise.then() and await callbacks run before macrotasks like setTimeout.

                    Promises are objects representing the result of an async operation, and we handle them with .then() or
                     .catch(). Async/await is built on top of Promises and makes async code look synchronous, improving readability.

                    For example, if I combine setTimeout, Promises, and async/await, the order is always: sync code first, 
                    then microtasks from Promises or await, and finally macrotasks like setTimeout. This is why understanding the 
                    event loop is crucial when debugging async behavior."*
                     Chcek => "js_async_cheatsheet.pdf"
                    
                    </pre>
            </div>
        </li>
        <li>
            <h4 class="blue">Sequential Promises</h4>
            <div>
                <pre>Definition : Promises that execute one after another.
                    ‚Ä¢ Each promise waits for the previous one to resolve before starting.
                    ‚Ä¢ Useful when tasks are dependent on each other.      
                </pre>
            </div>
                <h4><strong>Parallel Promises</strong> </h4>
                <pre> Definition : Promises that execute at the same time.
                    ‚Ä¢ They don‚Äôt wait for each other unless you explicitly gather results.
                    ‚Ä¢ Useful when tasks are independent.
                </pre>
        <li>
            <h4 class="blue"> Explain the event loop ?</h4>
            <div>
                <pre>Definition : The event loop is a mechanism in JavaScript that continuously checks the call stack and callback queue to execute asynchronous code without blocking the main thread.
                      And read from Theory section > eventLoop.html file  
                    C:\workspace-nisha\01_github\02_Javascript\javascript_project_2022\fullstack-interview-2025-website-solution\FrontendJS\Theory
                    </pre>
            </div>
        </li>

         <li>
            <h4 class="blue"> Explain Debounce & Throttle ?</h4>
            <div>
                <pre> Definition (Debounce) :  Debounce is a technique that delays a function‚Äôs execution until after a certain period of no repeated 
                    calls, mainly used to improve performance, like handling search input or resize events.
            
                   Definition (Throttle) :  Executes the function at fixed intervals, no matter how many times the event occurs.
               </pre>
                   <h4>What‚Äôs the difference between debounce and throttle?</h4>
                    <pre>
                        ‚Ä¢ Debounce waits until the user stops triggering the event, while throttle runs the function at fixed intervals during the event.
                        ‚Ä¢ Debounce waits for silence, throttle runs on a schedule.

                    Example:
                    Debounce: Typing in a search box ‚Üí API call happens only after user stops typing.
                    Throttle: Scrolling or window resize ‚Üí Function runs every 200ms while user keeps scrolling.
                </pre>
                <pre> In code language
                    ‚Ä¢  Debounce (search box):
                    const handleSearch = debounce((text) => console.log(text), 500);

                    ‚Ä¢  Throttle (scrolling):
                    const handleScroll = throttle(() => console.log("scroll"), 1000);


    Analogy (memorable) :
                üëâ ‚ÄúDebounce is like replying only after someone stops talking. 
                    Throttle is like nodding every few seconds while they talk continuously.‚Äù
                </pre>
            </div>
        </li>
           <li>
            <h4 class="blue"> Difference between process.nextTick and setImmediate [Node-specific features (process)]?</h4>
            <div>
                <pre>Definition : 
                    üîπ One-Line Comparison
                        ‚Ä¢ process.nextTick ‚Üí Runs immediately after the current function, before the event loop continues.
                        ‚Ä¢ setImmediate ‚Üí Runs on the next cycle of the event loop, after I/O tasks are done.
            
            üîπ Real-Time Scenarios

                1. process.nextTick (urgent micro task)
                
                    Example: You‚Äôre parsing a request and must validate it before doing anything else.
                    üëâ Here, the error is thrown right after the current stack, before event loop picks other tasks.

                2. setImmediate (defer heavy task) | macrotask
                    Example: You finished serving a client response, but want to log analytics without delaying I/O.
                    üëâ Logs happen after I/O is done, not blocking the response.

To use Node-specific features (process) inside the browser, which doesn‚Äôt have them.

                //1. process.nextTick (urgent micro task)

                    function handleRequest(data) {
                    if (!data.valid) {
                        process.nextTick(() => {
                        throw new Error("Invalid request");
                        });
                    }
                    console.log("Processing data...");
                    }
                    handleRequest({ valid: false });

                //2. setImmediate (defer heavy task)

                    server.on("request", (req, res) => {
                    res.end("Response sent!");
                    setImmediate(() => console.log("Log analytics for:", req.url));
                    });

</pre>

                    </div>
        </li>
    </ol>
</body> 

</html>