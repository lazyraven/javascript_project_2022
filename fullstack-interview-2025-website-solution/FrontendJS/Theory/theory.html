<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Theory Javascript</title>
</head>
<style>
    body {
         background: #333;
        color: whitesmoke;
        font-family: Verdana, Geneva, Tahoma, sans-serif
            /* font-family: 'Brush Script MT', cursive; */
    }

    .blue {
        color: blueviolet;
        font-weight: bold;
        display: inline;
    }

    p,
    pre {
        font-size: 16px;
    }

    #customlist {
        /* delete default counter */
        list-style-type: none;
        /* create custom counter and set it to 0 */
        counter-reset: elementcounter;
    }

    #customlist>li:before {
        /* print out "Element " followed by the current counter value */
        content: "Question " counter(elementcounter) ": ";
        /* increment counter */
        counter-increment: elementcounter;
        font-weight: bold;
        color: blueviolet;
    }
</style>

<body>
    <ol id="customlist">
        <li>
            <h4 class="blue">What is Javasecript ?</h4>
            <pre>
            JavaScript (JS) is a high-level, interpreted programming language mainly used to make web pages interactive, dynamic, and functional.
            It runs in the browser as well as on servers (using Node.js).

                ðŸ‘‰ With JS, you can:
                â€¢ Manipulate the DOM (change HTML/CSS dynamically).
                â€¢ Handle user events (clicks, forms, etc.).
                â€¢ Communicate with servers (API calls).
                â€¢ Build full-stack applications.

            In short: HTML gives structure, CSS gives style, and JavaScript gives behavior to web applications.
            </pre>
        </li>
        <li>
            <h4 class="blue">var vs let vs const </h4>
            <div>
                <pre>Definition : In JavaScript, var is function-scoped and allows redeclaration,
                            while let is block-scoped and can only be reassigned, not redeclared.
                            const is also block-scoped but values canâ€™t be reassigned.</pre>
            </div>
        </li>
        <li>
            <h4 class="blue">What is Scope ? </h4>
            <div>
                <pre>Definition : In JavaScript, scope defines the accessibility or visibility of variables, functions, and objects in different parts of the code.</pre>
                <pre>There are mainly three types of scope:

                    1. Global Scope â€“ variables accessible everywhere in the code.
                    2. Function Scope â€“ variables declared inside a function are accessible only within that function.
                    3. Global Scope â€“ variables accessible everywhere in the code.</pre>
            </div>
        </li>
        <li>
            <h4 class="blue">What is hoisting? </h4>
            <div>
                <p>Definition : Hoisting in JavaScript means variable and function declarations are moved to the top of
                    their
                    scope before code execution.</p>
                <pre>ðŸ‘‰ Explanation:
                   var â†’ hoisted with default value undefined.
                   let â†’ hoisted but in temporal dead zone, gives ReferenceError.
                   const â†’ same as let, but must be initialized at declaration.
                </pre>
                <pre>
            example covering var, let, and const hoisting in one go:
        <code>
            // var example
            console.log(a); // undefined
            var a = 10;

            // let example
            console.log(b); // ReferenceError
            let b = 20;

            // const example
            console.log(c); // ReferenceError
            const c = 30;
        </code>
        </pre>
            </div>
        </li>
        <li>
            <h4 class="blue">What is functions ? </h4>
            <div>
                <pre>Definition : A function in JavaScript is a reusable block of code designed to perform a specific task when called.
                They help in:
                    â€¢ Organizing code into smaller parts.
                    â€¢ Reusing logic without rewriting.
                    â€¢ Improving readability and maintainability.</pre>
            </div>
        </li>
        <li>
            <h4 class="blue">What is closure? </h4>
            <div>
                <pre>Definition : In JavaScript, a closure is created when a function is defined inside another function and 
                    the inner function "closes over" (remembers) the variables of the outer function.
                    It allows the inner function to access and manipulate those outer variables even after the outer function has returned.</pre>
                OR
                <pre>
            Closures : A closure is formed when a function â€œremembersâ€ its lexical scope even after the outer function has finished.
                       lexical scope means => inner function is lexical scope.
                    </pre>
                <h4 class="blue">Question 6.1: When is it(closure) useful? </h4>
                <pre>
                      1. Data Privacy / Encapsulation => You can hide variables from the outside world and expose only whatâ€™s necessary.
                      2. Maintaining State => Closures let functions "remember" past values even after their outer function has executed.
                      3. Callbacks & Event Handlers => Useful when passing functions around; they can access the outer scope variables they were created with.
                      4. Functional Programming => Helpful in currying, memoization, and creating higher-order functions.

                      âœ¨ In short: Closures are most useful when you need private variables, state persistence, or context preservation.
                      
                      Example :
                      function counter() {
                            let count = 0;
                            return function () {
                                count++;
                                return count;
                            };
                        }
                        const increment = counter();
                        console.log(increment()); // 1
                        console.log(increment()); // 2

          </pre>
                <h4 class="blue">Question 6.2: What is Lexical Scope? </h4>
                <pre>Definition : Lexical scope means a functionâ€™s scope is determined by where it is written in the code (not where it is called).
                Inner functions can access variables from their outer functions, but the reverse isnâ€™t true.
          </pre>
            </div>
        </li>

        <li>
            <h4 class="blue">What is IIFE (Immediately Invoked Function Expression) ? </h4>
            <div>
                <pre>Definition : An IIFE (Immediately Invoked Function Expression) is a JavaScript function that executes immediately after it is defined.
            
            <code>(function () {
            console.log("IIFE runs immediately!");
            })();
            </code>
        </pre>
            </div>
        </li>

        <li>
            <h4 class="blue">What is Prototypes ? </h4>
            <div>
                <pre>Definition : A prototype in JavaScript is an object from which other objects inherit properties and methods.
                                
                    Prototype chain in one line:
                If a property or method isnâ€™t found on an object, JavaScript looks up its prototype, then the prototypeâ€™s prototype, and
                so on, until it reaches null.
                
                const obj = {};
                console.log(obj.toString());
                // Not found in obj â†’ found in Object.prototype â†’ returns "[object Object]"
                </pre>
            </div>
        </li>
        <li>
            <h4 class="blue">Deep clone object ? </h4>
            <div>
                <pre>const clone = structuredClone(obj);
                    Best modern way (handles nested objects, arrays, Dates, Maps, Sets).

                    In Deep Learning : Go to this file C:\workspace-nisha\01_github\02_Javascript\javascript_project_2022\basic-tut-2025\JavaScript
                </pre>
            </div>
        </li>

        <li>
            <h4 class="blue">Difference between == and === </h4>
            <div>
                <pre>Definition :  == checks only for value equality with type conversion, while === checks for both value and type without conversion.
                    == â†’ compares only value.
                    === â†’ compares value + type.

                    5 == "5"   // true
                    5 === "5"  // false
                </pre>
            </div>
        </li>

        
        <li>
            <h4 class="blue">Explain this keyword in JS ? </h4>
            <div>
                <pre>Definition : In JavaScript, the this keyword is a special reference that points to the object that is currently executing the function. Its value depends on how the function is called, not where it is defined.
                        â€¢  this depends on how a function is called.
                        â€¢ Arrow functions do not bind their own this.

                 1. Inside an Object Method : 
                 2. In a Regular Function (Global Scope) :   
                 3. Inside a Constructor Function :  
                 4. In a Class :   
                 5. Arrow Functions :  
                </pre>
            </div>
        </li>

        <li>
            <h4 class="blue">What is call/apply/bind ?</h4>
            <div>
                <pre>Definition : 
                    â€¢ call â†’ Immediately invokes a function with a given this and arguments passed individually.

                    â€¢ apply â†’ Immediately invokes a function with a given this and arguments passed as an array.

                    â€¢ bind â†’ Returns a new function with a fixed this (and optional preset arguments), without calling it immediately.
               
               âš¡ Key difference: call/apply = immediate execution, bind = future execution.
                </pre>
            </div>
        </li>

         <li>
            <h4 class="blue"> Classes & inheritance ?</h4>
            <div>
                <pre>Definition : 1. What is a Class in JavaScript?
                    â€¢ A class is a blueprint for creating objects.
                    â€¢ It bundles properties (data) and methods(functions) together.
                    â€¢ Behind the scenes, classes use prototypes.

                    ðŸ”¹ 2. Inheritance
                    â€¢ Inheritance means one class can extend another.
                    â€¢ The child class inherits the parent's properties/methods and can also add its own.
                    â€¢ Achieved with the extend keyword.
                     OR 
                     Inheritance allows a class (child) to use properties and methods of another class (parent).

                    ðŸ”¹ 3. Key Points
                    â€¢ constructor() runs when you create a new object.
                    â€¢ super() is used in the child class to call the parentâ€™s constructor.
                    â€¢ Child classes can override methods.
                    â€¢ Classes are syntactic sugar over prototypes.
                </pre>
            </div>
        </li>

         <li>
            <h4 class="blue">What is Promises ?</h4>
            <div>
             <pre>Definition : 1. Promise: A Promise is an object that represents the eventual completion (or failure) of an asynchronous operation.

                    â€¢ It has 3 states:
                            â€¢ Pending â†’ initial state.
                            â€¢ Fulfilled â†’ operation completed successfully (resolved).
                            â€¢ Rejected â†’ operation failed (error).

                    â€¢ We use .then() for handling success and .catch() for handling errors, with .finally() for cleanup.
                </pre>
            </div>
        </li>

         <li>
            <h4 class="blue"> Explain Async/Await ?</h4>
            <div>
                <pre>Definition : 2. Async/Await: Introduced in ES2017, built on top of Promises.

                    â€¢ async makes a function return a Promise.
                    â€¢ await pauses execution until a Promise is resolved/rejected, making async code look synchronous.
                    â€¢ Helps avoid callback hell and makes code cleaner.

                    ðŸ‘‰ Promise = chaining
                    ðŸ‘‰ async/await = clean, synchronous-like</pre>
            </div>
        </li>

         <li>
            <h4 class="blue">Explain Promises, async/await ? </h4>
            <div>
                <pre> 
                    Expected Answer
                Step-by-step reasoning:

                1. Synchronous execution first:
                    â€¢ Logs "Start".
                    â€¢ Schedules setTimeout callback in the macrotask queue.
                    â€¢ Creates a resolved Promise â†’ schedules "Promise then" in the microtask queue.
                    â€¢ Calls test():
                    â€¢ Logs "Inside async".
                    â€¢ Hits await Promise.resolve(), which pauses execution and schedules "After await" in the microtask queue.
                    â€¢ Logs "End".

                2. Microtasks run before macrotasks:
                    â€¢ "Promise then" logs.
                    â€¢ "After await" logs.
                    â€¢ The await pauses execution until the Promise resolves.

                3. Finally, macrotasks run:
                    â€¢ "setTimeout" logs.

                    ðŸ‘‰ Output:
                                Start   
                                Inside async
                                End
                                Promise then
                                After await
                                setTimeout


                        â€¢ Synchronous code runs first.
                        â€¢ Microtasks (Promises, async/await) run next.
                        â€¢ Macrotasks (setTimeout, setInterval, I/O) run last.

                        console.log("Check Other practice => C:workspace-nisha\x01_github\x02_Javascriptjavascript_project_2022\basic-tut-2025JavaScript");
                    
                    
                    Spoken Answer : 
                    *"In JavaScript, execution follows the event loop model. First, synchronous code runs top to bottom. After
                     that, microtasks like Promise.then() and await callbacks run before macrotasks like setTimeout.

                    Promises are objects representing the result of an async operation, and we handle them with .then() or
                     .catch(). Async/await is built on top of Promises and makes async code look synchronous, improving readability.

                    For example, if I combine setTimeout, Promises, and async/await, the order is always: sync code first, 
                    then microtasks from Promises or await, and finally macrotasks like setTimeout. This is why understanding the 
                    event loop is crucial when debugging async behavior."*
                     Chcek => "js_async_cheatsheet.pdf"
                    
                    </pre>
            </div>
        </li>
        <li>
            <h4 class="blue">Sequential Promises</h4>
            <div>
                <pre>Definition : Promises that execute one after another.
                    â€¢ Each promise waits for the previous one to resolve before starting.
                    â€¢ Useful when tasks are dependent on each other.      
                </pre>
            </div>
                <h4><strong>Parallel Promises</strong> </h4>
                <pre> Definition : Promises that execute at the same time.
                    â€¢ They donâ€™t wait for each other unless you explicitly gather results.
                    â€¢ Useful when tasks are independent.
                </pre>
        <li>
            <h4 class="blue"> Explain the event loop ?</h4>
            <div>
                <pre>Definition : The event loop is a mechanism in JavaScript that continuously checks the call stack and callback queue to execute asynchronous code without blocking the main thread.
                      And read from Theory section > eventLoop.html file  
                    C:\workspace-nisha\01_github\02_Javascript\javascript_project_2022\fullstack-interview-2025-website-solution\FrontendJS\Theory
                    </pre>
            </div>
        </li>
    </ol>
</body> 

</html>