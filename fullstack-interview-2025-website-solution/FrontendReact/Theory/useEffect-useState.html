<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Useeffect/useState</title>
</head>
<style>
    body {
        /* background: #333;
        color: whitesmoke; */
        font-family: Verdana, Geneva, Tahoma, sans-serif
            /* font-family: 'Brush Script MT', cursive; */
    }

    .blue {
        color: blueviolet;
        font-weight: bold;
        display: inline;
    }

    p,
    pre {
        font-size: 16px;
    }

    #customlist {
        /* delete default counter */
        list-style-type: none;
        /* create custom counter and set it to 0 */
        counter-reset: elementcounter;
    }

    #customlist>li:before {
        /* print out "Element " followed by the current counter value */
        content: "Question " counter(elementcounter) ": ";
        /* increment counter */
        counter-increment: elementcounter;
        font-weight: bold;
        color: blueviolet;
    }
</style>

<body>
    <ol id="customlist">
        <li>
            <h4 class="blue">ðŸ”¹ Common Follow-ups on useState / useEffect</h4>
            <pre>
                1. Can we use multiple useEffects in one component?
                Yes. Unlike class lifecycle methods, we can call useEffect multiple times in the same component to separate concerns. For example, one effect for data fetching and another for event listeners.

                2. Whatâ€™s the difference between useEffect and useLayoutEffect?

                â€¢ useEffect runs after the render is painted to the screen (asynchronous, non-blocking).
                â€¢ useLayoutEffect runs before the paint (synchronous), which is useful when you need DOM measurements or to avoid flickering.

                3. Why do we pass dependencies to useEffect?
                The dependency array tells React when to re-run the effect.

                â€¢ [] â†’ run only once (on mount).
                â€¢ [var] â†’ run when var changes.
                â€¢ no array â†’ run on every render.

                4. Can useState updates be batched?
                Yes. In React 18, state updates inside event handlers are batched automatically for performance.

                5. How do you clean up in useEffect?
                By returning a function from the effect. Example: removing event listeners or canceling subscriptions when a component unmounts.

                Code snippet

                useEffect(() => {
                    const handleResize = () => console.log(window.innerWidth);
                    window.addEventListener("resize", handleResize);

                    return () => {
                        window.removeEventListener("resize", handleResize);
                    };
                }, []);

            </pre>
        </li>
      
    </ol>
</body>

</html>