<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="https://img.icons8.com/?size=100&id=123603&format=png&color=000000">
  <title>React Q&A Plan</title>
<style>
    body {
        background-color: #111;
        color: #fff;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 20px;
    }

    .question-grid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 10px;
        margin-bottom: 20px;
    }

    .question-card {
        background: #1e1e1e;
        border: 1px solid #333;
        border-radius: 6px;
        padding: 10px;
        font-size: 14px;
        cursor: pointer;
        transition: 0.3s;
        text-align: center;
        line-height: 1.3;
    }

    .question-card:hover {
        background-color: #272727;
    }

    .definition-section {
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 25px;
        transition: all 0.4s ease;
    }

    .definition-section.highlight {
        border: 2px solid #b366ff;
        box-shadow: 0 0 15px #b366ff66;
        background: #2a1a3a;
    }

    .definition-section h3 {
        color: #b366ff;
        margin-bottom: 8px;
    }

    html {
        scroll-behavior: smooth;
    }

    /* === Back to Top Button Styling === */
    #backToTopBtn {
        display: none;
        position: fixed;
        bottom: 25px;
        right: 25px;
        background-color: #b366ff;
        color: #fff;
        border: none;
        border-radius: 50%;
        width: 45px;
        height: 45px;
        font-size: 20px;
        cursor: pointer;
        box-shadow: 0 0 10px #b366ff80;
        transition: all 0.3s ease;
        z-index: 1000;
    }

    #backToTopBtn:hover {
        background-color: #9933ff;
        box-shadow: 0 0 20px #b366ff;
        transform: scale(1.1);
    }
    /* === Floating Theme Toggle Button === */
    #themeToggle {
        position: fixed;
        top: 20px;
        right: 25px;
        z-index: 1100;
        cursor: pointer;
        background: #fff;
        color: #0d6efd;
        border: none;
        padding: 10px 16px;
        border-radius: 30px;
        font-weight: bold;
        font-size: 14px;
        box-shadow: 0 0 10px #b366ff60;
        transition: all 0.3s ease;
    }

    #themeToggle:hover {
        transform: scale(1.1);
        background: #0d6efd;
        color: #fff;
        box-shadow: 0 0 15px #b366ff90;
    }

    /* === Smooth Fade Animation for Theme Switch === */
    body {
        transition: background-color 0.5s ease, color 0.5s ease;
    }

    .definition-section,
    .question-card,
    #backToTopBtn {
        transition: background-color 0.5s ease, color 0.5s ease, box-shadow 0.5s ease;
    }

    /* === Light Mode === */
    body.light-mode {
        background-color: #f5f5f5;
        color: #111;
    }

    body.light-mode .question-card {
        background: #fff;
        border: 1px solid #ccc;
        color: #000;
    }

    body.light-mode .question-card:hover {
        background-color: #f0f0f0;
    }

    body.light-mode .definition-section {
        background: #fff;
        border: 1px solid #ddd;
        color: #000;
    }

    body.light-mode .definition-section h3 {
        color: #7a3fff;
    }

    body.light-mode #backToTopBtn {
        background-color: #7a3fff;
    }

    body.light-mode #themeToggle {
        background: #0d6efd;
        color: #fff;
    }

    /* === Responsive Adjustments === */
    @media (max-width: 600px) {
        #themeToggle {
            top: 15px;
            right: 15px;
            padding: 8px 14px;
            font-size: 13px;
        }
    }
    pre{
        font-size: 16px;
    }
</style>
</head>
<body>  ‚úÖ Week 2 ‚Äì React Topics
  https://chatgpt.com/share/693fc93d-7f04-8013-9ff5-516fd69103be > read it again from here and update the notes..........., 
  https://chatgpt.com/c/693cf817-ab80-8322-9f77-9e4d37be94b9 > memorize
<button id="themeToggle">‚òÄÔ∏è Light</button>
<div>
    <h4><a target="_target"
            href="https://fullstack-interview-roadmap.netlify.app/">fullstack-interview-roadmap solution | ‚úÖ Week 2 ‚Äì React Prep</a>
    </h4>
</div>
  <div class="question-grid" id="questionGrid"></div>
  <div id="definitionContainer"></div>

  <!-- Back to Top Button -->
  <button id="backToTopBtn" title="Go to top">‚Üë</button>

  <script>

// for question questionId , I'm handling with index, no need of questionId
const reactQuestions = [
  {
    questionId: 1,
    question: "What is (React) ‚Äì JSX (JavaScript XML)?",
    definition: `In-short : JSX ‚Üí whenever writing UI structure.

‚Ä¢ A syntax extension for JavaScript that lets you write HTML-like code inside JavaScript.
‚Ä¢ JSX is not required, but it makes UI easier to write and read.
‚Ä¢ Under the hood, JSX compiles into React.createElement(...).

üëâ Where to use it:
‚Ä¢ Whenever you want to define UI structure in React.

Use JSX in all React components unless you want to work only with raw JavaScript.`
  },
  {
    questionId: 2,
    question: "What is Components?",
    definition: `In-short : JSX ‚Üí To break UI into small, reusable pieces.

‚Ä¢ Reusable building blocks of a React app.
‚Ä¢ Two types:
   ‚Ä¢ Functional components (modern standard, simpler)
   ‚Ä¢ Class components (older, rarely needed now).

üëâ Where to use it:
‚Ä¢ Every piece of UI should ideally be a component.
‚Ä¢ Helps you split big UI into small, reusable, independent pieces.

üí° Use components for modularity, reusability, and maintainability.`
  },
  {
    questionId: 3,
    question: "What is Props?",
    definition: `In-short : To pass data into components (read-only, like parameters).

‚Ä¢ Short for properties.
‚Ä¢ Data passed from parent to child (read-only).
‚Ä¢ Think of them like function parameters.

üëâ Where to use it:
‚Ä¢ When you want to customize a component with external data.`
  },
  {
    questionId: 4,
    question: "What is State?",
    definition: `In-short : To manage data inside a component (can change, triggers re-render).

‚Ä¢ A built-in object that stores data inside a component.
‚Ä¢ Unlike props, state is managed within the component and can change over time.
‚Ä¢ When state changes ‚Üí React re-renders the UI.

üëâ Where to use it:
‚Ä¢ For data that changes within the component (user input, API results, toggle, counters, etc.).`
  },
  {
    questionId: 5,
    question: "What is Class Component?",
    definition: `In-short : Class components are ES6 classes that extend React.Component using this.state and lifecycle methods.

ES6 class
‚Ä¢ this.state and setState()
‚Ä¢ Methods like componentDidMount, componentDidUpdate
‚Ä¢ Must handle this binding.
‚Ä¢ Slightly heavier, older approach`
  },
  {
    questionId: 6,
    question: "What is Functional Component?",
    definition: `In-short : While functional components are plain functions that use hooks like useState and useEffect.
Functional components are now preferred because they‚Äôre simpler, cleaner, and the modern React standard.

Plain JS function
‚Ä¢ useState, useReducer 
‚Ä¢ Hooks like useEffect 
‚Ä¢ No this, simpler
‚Ä¢ Lighter, often preferred, Cleaner, concise

* Class components are mainly for older React codebases, 
while functional components with hooks are the modern standard for new projects because they‚Äôre simpler and more efficient.`
  },
  {
    questionId: 7,
    question: "What is (React) ‚Äì useEffect, useState, lifecycle?",
    definition: `useEffect is a React Hook used to handle side effects in functional components, such as data fetching, subscriptions, timers, and DOM updates.
In React, useState lets us add and manage state in functional components. 

It runs after the component renders and allows us to synchronize the component with external systems like APIs or browser events.

With hooks, we manage them inside a single functional component in a cleaner, more readable way.
useEffect can return a cleanup function to avoid memory leaks.

Used for:
  ‚Ä¢ Event listeners
  ‚Ä¢ Subscriptions
  ‚Ä¢ Timers
  ‚Ä¢ WebSocket connections

Common Use Cases :

  ‚Ä¢ API calls
  ‚Ä¢ Authentication checks
  ‚Ä¢ Event listeners
  ‚Ä¢ Timers and intervals
  ‚Ä¢ Updating document title

useEffect vs Lifecycle Methods
‚ÄúuseEffect replaces componentDidMount, componentDidUpdate, and componentWillUnmount from class components.‚Äù

Common Mistakes (Good to Mention)
  ‚Ä¢ Missing dependencies
  ‚Ä¢ Infinite loops
  ‚Ä¢ Using async directly in useEffect

 Correct async pattern: in code
 
'It can be configured to run once (like componentDidMount), on every render (componentDidUpdate), or for cleanup (componentWillUnmount). 
In class components, these behaviors are split across lifecycle methods.
`
  },
  {
    questionId: '',
    question: "What is useState ?",
    definition: `Short & Strong Answer (Start Here) : useState is a React Hook used to manage local state in functional components.
Slightly Detailed Explanation :
‚ÄúIt allows a component to store and update state values, and whenever the state changes, the component re-renders with the updated data.‚Äù

How State Updates Work :
State updates using setState are asynchronous and trigger a re-render.

Common Use Cases:
  ‚Ä¢ Form inputs
  ‚Ä¢ Toggle buttons
  ‚Ä¢ Counters
  ‚Ä¢ Modal open/close
  ‚Ä¢ Tabs and UI state

  interview Line: We can use multiple useState hooks to manage independent pieces of state.

useState vs Props (Quick Comparison):
Props are read-only and passed from parent, while state is mutable and managed within the component.

| useState         | useReducer                  |
| ---------------- | --------------------------- |
| Simple state     | Complex state logic         |
| Less boilerplate | Better for multiple actions |
| Easy to read     | More structured             |


Common Mistakes (Good to Mention):
‚Ä¢ Mutating state directly
‚Ä¢ Forgetting previous state
‚Ä¢ Using state when variable is enough
Wrong:
count++;

Correct:
setCount(count + 1);

    `
  },
  {
    questionId: 8,
    question: "How does React‚Äôs virtual DOM work?",
    definition: `React‚Äôs Virtual DOM is a lightweight copy of the real DOM. When the state changes, React updates the Virtual DOM first, 
compares it with the previous version (diffing), and then updates only the changed parts in the real DOM for efficiency.

üëâ Quick reply: ‚ÄúReact uses a Virtual DOM to track changes. 
It compares new and old states (diffing) and updates only the necessary parts in the real DOM for faster performance.‚Äù`
  },
  {
    questionId: 9,
    question: "What is Routing - React Router?",
    definition: `React Router enables navigation in a React app without reloading the page. 
It maps URLs to components, making single-page apps feel like multi-page apps.

* React Router lets you navigate between views in a React app without refreshing the page.`
  },
  {
    questionId: 10,
    question: "What is SPA (Single Page Application) vs MPA (Multi Page Application)?",
    definition: `SPA (Single Page Application) loads one HTML file and updates content dynamically without full reloads, giving a smoother, faster experience. 
MPA (Multi Page Application) loads a new HTML page for every request, which is heavier but better for SEO and complex apps.

* One-liner fallback:
‚ÄúSPA updates content dynamically on one page, while MPA reloads new pages for each request.‚Äù

üëâ Quick memory hook:

SPA = Speedy & smooth (but SEO issues).
MPA = SEO-friendly (but slower UX).

SPA (Single Page Application)
‚úÖ Pros:
‚Ä¢ Faster, smoother user experience (no full page reloads)
‚Ä¢ Efficient data fetching (API-driven)
‚Ä¢ Great for dynamic, interactive apps (e.g., Gmail, Twitter)

‚ùå Cons:
‚Ä¢ SEO challenges (requires SSR or pre-rendering)
‚Ä¢ Larger initial load time
‚Ä¢ Can be complex for very large apps

MPA (Multi Page Application)
‚úÖ Pros:
‚Ä¢ Better SEO by default (separate pages with metadata)
‚Ä¢ Easier to manage very large, content-heavy apps
‚Ä¢ Built-in security (less exposed frontend code)

‚ùå Cons:
‚Ä¢ Slower (full reload on every navigation)
‚Ä¢ Heavier server load
‚Ä¢ More repetitive frontend code`
  },
  {
    questionId: 11,
    question: "What is state management Redux?",
    definition: `Redux is a state management library for JavaScript apps. Redux stores the entire application state in a single store.
     State changes happen only through dispatched actions and pure reducers, which makes the data flow predictable and easier to debug.

 especially for large React applications.

 Redux Data Flow (Very Important)

‚ÄúRedux follows a unidirectional data flow:
UI ‚Üí dispatch action ‚Üí reducer updates state ‚Üí UI re-renders.‚Äù

Redux Toolkit (Modern Redux ‚Äì Interview Favorite)
‚ÄúToday, we mostly use Redux Toolkit, which reduces boilerplate and provides best practices by default.‚Äù
Context solves prop drilling, but Redux solves complex state logic.

When to Use Redux

  Use Redux when:
  ‚Ä¢ App has complex state logic
  ‚Ä¢ Many components depend on the same data
  ‚Ä¢ Async operations (API calls)
  ‚Ä¢ Need debugging, logging, time-travel

  Avoid Redux when:
  ‚Ä¢ App is small
  ‚Ä¢ State is local or simple

 Async Handling (Extra Points)
‚ÄúRedux handles async logic using middleware like Thunk or Saga.‚Äù

Real-World Use Cases :
  ‚Ä¢ Authentication
  ‚Ä¢ Shopping cart
  ‚Ä¢ Dashboard data
  ‚Ä¢ User permissions
  ‚Ä¢ Caching API responses

  Redux provides predictable, scalable state management and is ideal for complex React applications when used with Redux Toolkit.
  One-Line : Redux optimizes re-renders by allowing components to subscribe only to required state.
`
  },
  {
    questionId: 12,
    question: "What is Context API vs Redux?",
    definition: `The Context API in React is used to share data globally across components without passing props manually at every level. 
  It helps avoid prop drilling and is commonly used for data like themes, authentication, and user settings.

    Context API allows us to create a centralized store using createContext, provide data using a Provider, and consume it using useContext.
    Any component inside the Provider can access the shared state directly.

When to Use Context API

  Use it when:
  ‚Ä¢ Avoiding prop drilling
  ‚Ä¢ Sharing global state
  ‚Ä¢ Managing theme, language, auth user, permissions

  Avoid it when:
  ‚Ä¢ State changes frequently (can cause re-renders)
  ‚Ä¢ Complex state logic (Redux/Zustand is better)

Context API vs Props (One-Line Comparison): Props are for parent-child communication, while Context is for sharing data across multiple levels of the component tree.

Redux is a standalone library with a single global store, better for large, complex apps needing predictable state and advanced debugging.

| Context API                 | Redux                 |
| --------------------------- | --------------------- |
| Built-in React feature      | External library      |
| Good for small/global state | Better for large apps |
| Simple setup                | More boilerplate      |
| No middleware               | Supports middleware   |

One-liner fallback:
‚ÄúContext API is suitable for simpler global state, while Redux is better for complex state management.‚Äù
`
  },
  {
    questionId: 13,
    question: "Technical Implementation - React Hooks Used?",
    definition: `---------------------------------------
      React Hooks Used
      ---------------------------------------

      Hook            | Purpose
      ---------------------------------------------
      useState        | Local component state management
      useEffect       | Side effects and API calls
      useMemo         | Optimized filtering and calculations
      useCallback     | Memoized event handlers
      useContext      | Global state access
      ---------------------------------------------
      A custom React hook (useLocalStorage)
      `
  },
  {
    questionId: 14,
    question: "Technical Implementation - üìà Performance Optimizations?",
    definition: `---------------------------------------
      üìà Performance Optimizations
---------------------------------------
Technique            | Implementation                   | Benefit
---------------------------------------------------------------------------
useMemo              | Filtered tasks calculation       | Prevents unnecessary re-renders
Optimistic Updates   | UI updates before API response   | Better perceived performance
Lazy Loading         | Components load on demand        | Faster initial load
Error Boundaries     | Graceful error handling          | Better user experience
--------------------------------------------------------------------------- `
  },
  {
    questionId: 15,
    question: "Save & Load Data from LocalStorage?",
    definition: `In React, one common way to persist data is using LocalStorage, which stores key‚Äìvalue data in the browser.`
  },
  {
    questionId: 16,
    question: "Why use vite for react framework or other?",
    definition: `
Vite is used with React (and many other frontend frameworks) because it solves several performance and
developer-experience limitations found in older bundlers like Webpack.
‚Ä¢ Vite uses esbuild, which is extremely fast (written in Go).
‚Ä¢ Vite serves your code with native ES modules‚Äîno heavy bundling during development.
‚Ä¢ Webpack/Snowpack/Rollup dev servers tend to slow down as your project grows. Vite stays fast.

Native ES Modules (ESM) modern browser : means the browser can directly load JavaScript modules without needing a bundler like Webpack first.
‚Ä¢ Modern browsers now understand import and export directly.
‚Ä¢ Developers wrote code using import/export, but bundlers had to convert everything into one big file.
Vite uses a bundler (Rollup) only for production, not dev.
    `
  },
  {
    questionId: 17,
    question: "Why does mean of bundler?",
    definition: `
  ‚Ä¢ Popular bundlers

  ‚Ä¢ Webpack (older, very common)

  ‚Ä¢ Rollup

  ‚Ä¢ Parcel

  ‚Ä¢ Esbuild
  Vite uses a bundler (Rollup) only for production, not dev.
    `
  },
  
  {
    questionId: 18,
    question: "what does mean react memoization?",
    definition: `React memoization refers to techniques that help React avoid unnecessary re-renders by remembering (‚Äúmemoizing‚Äù) 
the result of a function or component until its inputs change.

key parts :
 1. React.memo (for components) - Wraps a component so React only re-renders it when its props change.
 2. useMemo (for expensive calculations) - Caches the return value of a heavy computation.
 3. useCallback (for functions) - Memoizes a function so its identity doesn‚Äôt change between renders.
`
  },
  {
    questionId: 19,
    question: "useCallback",
    definition: `useCallback is a React Hook used to memoize functions so they are not recreated on every render, which helps prevent unnecessary re-renders.
 It returns a cached version of a function that only changes when its dependencies change. This is especially useful when passing functions as props to child components
   
Why useCallback is Needed (Interview Favorite)

  Problem:
  Every render creates a new function reference.

  Solution:
  useCallback preserves the same function reference unless dependencies change.

  useCallback vs useMemo (Very Common Question)
  | useCallback         | useMemo                           |
| ------------------- | --------------------------------- |
| Memoizes a function | Memoizes a value                  |
| Returns a function  | Returns a value                   |
| Prevents re-renders | Prevents expensive recalculations |

Interview line:
useCallback(fn) is equivalent to useMemo(() => fn).

When to Use useCallback :

  Use it when:
  ‚Ä¢ Passing callbacks to memoized child components
  ‚Ä¢ Functions used in dependency arrays
  ‚Ä¢ Avoiding re-renders in performance-critical components

  Avoid it when:
  ‚Ä¢ Functions are simple
  ‚Ä¢ No performance issue exists

Dependency Array (Important)
‚ÄúIncorrect dependencies can cause stale data or bugs.‚Äù
Overusing useCallback can add complexity and memory overhead, so it should be used selectively.‚Äù
 `
  },
    {
    questionId: 20,
    question: "What is  ?",
    definition: `

    `
  },
];


    const questionGrid = document.getElementById("questionGrid");
    const definitionContainer = document.getElementById("definitionContainer");

    reactQuestions.forEach((item, index )=> {
      // create top question box
      const card = document.createElement("div");
      card.className = "question-card";
      // card.innerHTML = `<strong style="color:#b366ff;">Q${item.questionId}:</strong> ${item.question}`;
      // id maintain based on index
      card.innerHTML = `<strong style="color:#b366ff;">Q${index+1}:</strong> ${item.question}`;
      // card.addEventListener("click", () => scrollToDefinition(item.questionId));
      card.addEventListener("click", () => scrollToDefinition(index+1));
      questionGrid.appendChild(card);

      // create definition section
      const def = document.createElement("div");
      def.className = "definition-section";
      // def.id = `question-${item.questionId}`;
      // id maintain based on index
      def.id = `question-${index+1}`;
      def.innerHTML = `
        <h3>Question ${index+1}: ${item.question}</h3>
        <pre>${item.definition}</pre>
      `;
      definitionContainer.appendChild(def);
    });

    function scrollToDefinition(id) {
      const target = document.getElementById(`question-${id}`);
      if (target) {
        target.scrollIntoView({ behavior: "smooth", block: "start" });
        target.classList.add("highlight");
        setTimeout(() => target.classList.remove("highlight"), 1500);
      }
    }

    
    // === Back to Top Button Logic ===
    const backToTopBtn = document.getElementById("backToTopBtn");

    window.addEventListener("scroll", () => {
      if (document.body.scrollTop > 300 || document.documentElement.scrollTop > 300) {
        backToTopBtn.style.display = "block";
      } else {
        backToTopBtn.style.display = "none";
      }
    });

    backToTopBtn.addEventListener("click", () => {
      window.scrollTo({ top: 0, behavior: "smooth" });
    });


   /// === Theme Toggle Logic with Icons and Fade ===
    const themeToggle = document.getElementById("themeToggle");
    const body = document.body;

    // Load saved theme preference
    if (localStorage.getItem("theme") === "light") {
    enableLightMode(false);
    } else {
    enableDarkMode(false);
    }

    themeToggle.addEventListener("click", () => {
    body.classList.add("fade-transition");
    if (body.classList.contains("light-mode")) {
        enableDarkMode();
    } else {
        enableLightMode();
    }
    setTimeout(() => body.classList.remove("fade-transition"), 400);
    });

    function enableLightMode(save = true) {
    body.classList.add("light-mode");
    themeToggle.innerHTML = "üåô Dark";
    if (save) localStorage.setItem("theme", "light");
    }

    function enableDarkMode(save = true) {
    body.classList.remove("light-mode");
    themeToggle.innerHTML = "‚òÄÔ∏è Light";
    if (save) localStorage.setItem("theme", "dark");
    }
  </script>
</body>
</html>
